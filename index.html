<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="大前段">
<meta property="og:type" content="website">
<meta property="og:title" content="Eric.T">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Eric.T">
<meta property="og:description" content="大前段">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Eric.T">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>Eric.T</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eric.T</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/03/JS%20%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C%20----%20%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric.T">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/03/JS%20%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C%20----%20%E5%BE%AA%E7%8E%AF/" itemprop="url">JS 常规操作 ----- 循环</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-03T21:07:10+08:00">
                2021-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是渲染"><a href="#什么是渲染" class="headerlink" title="什么是渲染"></a>什么是渲染</h3><p>循环也被称之为遍历，就是把你需要的全部东西都找出来，常规操作中都是用 for 循环我们需要的东西，把里面的细节给找出来。</p>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>我们一开是接触的 for 是这样写的：</p>
<pre><code>for (let i = 0; i &lt; len.length; i ++) &#123;
    console.log( len[i] )
&#125;
</code></pre>
<p>这样写是完全没问题的，但是对于比较喜欢偷懒的程序员来说，每次写 for 循环的时候都要写 (let i = 0; i &lt; len.length; i ++) 这个不是什么舒服的事情，经过一点点升级 我们可以用 in 或 of 来代替括号中的内容比如：</p>
<pre><code>for (let i in len) &#123;
    console.log( len[i] )
&#125;
</code></pre>
<p>这样写就能大大提高写 for 循环的效率，但是有时候还会遇到点问题就是偷懒想把这个 for 循环再简化下，这时候我们可以用到 forEach，可以这样写：</p>
<pre><code>var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
array.forEach(function(element) &#123;
  console.log(element);
&#125;);
</code></pre>
<p>这样写的话还有一些地方可以优化，就是尖头函数：</p>
<pre><code>var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
array.forEach((element) =&gt; &#123;
  console.log(element);
&#125;);
</code></pre>
<p>说到 forEach，可以扩展到 map 方法，该方法和 forEach 的区别：</p>
<p>forEach 是没有返回值的，比如：</p>
<pre><code>var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
var e = array.forEach((element) =&gt; &#123;
  console.log(element);
&#125;);
console.log(e) //undefined
</code></pre>
<p>map 有返回值的，比如：</p>
<pre><code>var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
var e = array.map((element) =&gt; &#123;
  return element
&#125;);
console.log(e) //[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

如果不写return的话，那么就会显示
console.log(e) //[undefined, undefined, undefined]
</code></pre>
<p>那么我们什么时候用 foreach 什么时候用 map 呢，在我看来 如果你需要一个新的值去接收遍历后的结果那么就用 map；如果只是单单想通过循环去做某件事，那么用 map 和 forEach 都是可以的</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>说完 map 之后，还有一些常用的函数推荐给大家，reduce，filter，every，some</p>
<h4 id="some-用法"><a href="#some-用法" class="headerlink" title="some 用法"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-some.html">some 用法</a></h4><h5 id="some-方法用于检测数组中的元素是否满足指定条件（函数提供）。"><a href="#some-方法用于检测数组中的元素是否满足指定条件（函数提供）。" class="headerlink" title="some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。"></a>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</h5><h5 id="some-方法会依次执行数组的每个元素："><a href="#some-方法会依次执行数组的每个元素：" class="headerlink" title="some() 方法会依次执行数组的每个元素："></a>some() 方法会依次执行数组的每个元素：</h5><ul>
<li>如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。</li>
<li>如果没有满足条件的元素，则返回 false。</li>
</ul>
<h5 id="array-some-function-currentValue-index-arr-thisValue"><a href="#array-some-function-currentValue-index-arr-thisValue" class="headerlink" title="array.some(function(currentValue,index,arr),thisValue)"></a>array.some(function(currentValue,index,arr),thisValue)</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>currentValue</td>
<td>必须。当前元素的值</td>
</tr>
<tr>
<td>index</td>
<td>可选。当前元素的索引值</td>
</tr>
<tr>
<td>arr</td>
<td>可选。当前元素属于的数组对象</td>
</tr>
<tr>
<td>thisValue</td>
<td>可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue ，”this” 的值为 “undefined”</td>
</tr>
<tr>
<td>返回值</td>
<td>布尔值。如果数组中有元素满足条件返回 true，否则返回 false。</td>
</tr>
</tbody></table>
<h4 id="every-用法"><a href="#every-用法" class="headerlink" title="every 用法"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-every.html">every 用法</a></h4><h5 id="every-方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。"><a href="#every-方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。" class="headerlink" title="every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。"></a>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。</h5><h5 id="every-方法使用指定函数检测数组中的所有元素："><a href="#every-方法使用指定函数检测数组中的所有元素：" class="headerlink" title="every() 方法使用指定函数检测数组中的所有元素："></a>every() 方法使用指定函数检测数组中的所有元素：</h5><ul>
<li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li>
<li>如果所有元素都满足条件，则返回 true。</li>
</ul>
<h5 id="array-every-function-currentValue-index-arr-thisValue"><a href="#array-every-function-currentValue-index-arr-thisValue" class="headerlink" title="array.every(function(currentValue,index,arr), thisValue)"></a>array.every(function(currentValue,index,arr), thisValue)</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>currentValue</td>
<td>必须。当前元素的值</td>
</tr>
<tr>
<td>index</td>
<td>可选。当前元素的索引值</td>
</tr>
<tr>
<td>arr</td>
<td>可选。当前元素属于的数组对象</td>
</tr>
<tr>
<td>thisValue</td>
<td>可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue ，”this” 的值为 “undefined”</td>
</tr>
<tr>
<td>返回值</td>
<td>布尔值。如果数组中有元素满足条件返回 true，否则返回 false。</td>
</tr>
</tbody></table>
<h4 id="filter-用法"><a href="#filter-用法" class="headerlink" title="filter 用法"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-filter.html">filter 用法</a></h4><h5 id="filter-方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。"><a href="#filter-方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。" class="headerlink" title="filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。"></a>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</h5><h5 id="array-filter-function-currentValue-index-arr-thisValue"><a href="#array-filter-function-currentValue-index-arr-thisValue" class="headerlink" title="array.filter(function(currentValue,index,arr), thisValue)"></a>array.filter(function(currentValue,index,arr), thisValue)</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>currentValue</td>
<td>必须。当前元素的值</td>
</tr>
<tr>
<td>index</td>
<td>可选。当前元素的索引值</td>
</tr>
<tr>
<td>arr</td>
<td>可选。当前元素属于的数组对象</td>
</tr>
<tr>
<td>thisValue</td>
<td>可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue ，”this” 的值为 “undefined”</td>
</tr>
<tr>
<td>返回值</td>
<td>返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。</td>
</tr>
</tbody></table>
<h4 id="reduce-用法-重点"><a href="#reduce-用法-重点" class="headerlink" title="*reduce 用法 (重点)"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-reduce.html">*reduce 用法 (重点)</a></h4><h5 id="reduce-方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。"><a href="#reduce-方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。" class="headerlink" title="reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。"></a>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</h5><h5 id="reduce-可以作为一个高阶函数，用于函数的-compose。"><a href="#reduce-可以作为一个高阶函数，用于函数的-compose。" class="headerlink" title="reduce() 可以作为一个高阶函数，用于函数的 compose。"></a>reduce() 可以作为一个高阶函数，用于函数的 compose。</h5><h5 id="array-reduce-function-total-currentValue-currentIndex-arr-initialValue"><a href="#array-reduce-function-total-currentValue-currentIndex-arr-initialValue" class="headerlink" title="array.reduce(function(total, currentValue, currentIndex, arr), initialValue)"></a>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>total</td>
<td>必需。初始值, 或者计算结束后的返回值。</td>
</tr>
<tr>
<td>currentValue</td>
<td>必需。当前元素值</td>
</tr>
<tr>
<td>currentIndex</td>
<td>可选。当前元素的索 引</td>
</tr>
<tr>
<td>arr</td>
<td>可选。当前元素所属的数组对象。</td>
</tr>
<tr>
<td>返回值</td>
<td>返回计算结果</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们循环遍历都是为了方便我们对数据更好的操作，在合适的地点用适当的方式能轻松解决我们绝大部分问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/02/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric.T">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/02/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/" itemprop="url">JS原型链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-02T21:00:33+08:00">
                2021-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官方说法：每个函数都有一个 prototype 属性<br>每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>我的理解：说到底就是一个继承的方式，把你的某部分放入我这里，当你那部分改变时，我这里也会跟着改变</p>
<h2 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h2><p>JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<h5 id="让我们从一个函数里创建一个对象-o，它自身拥有属性-a-和-b-的："><a href="#让我们从一个函数里创建一个对象-o，它自身拥有属性-a-和-b-的：" class="headerlink" title="// 让我们从一个函数里创建一个对象 o，它自身拥有属性 a 和 b 的："></a>// 让我们从一个函数里创建一个对象 o，它自身拥有属性 a 和 b 的：</h5><p>let f = function () {<br>this.a = 1;<br>this.b = 2;<br>}</p>
<p>/_ 这么写也一样<br>function f() {<br>this.a = 1;<br>this.b = 2;<br>}<br>_/</p>
<p>let o = new f(); // {a: 1, b: 2}</p>
<p>// 在 f 函数的原型上定义属性</p>
<p>f.prototype.b = 3;</p>
<p>f.prototype.c = 4;</p>
<h5 id="不要在-f-函数的原型上直接定义-f-prototype-b-3-c-4-这样会直接打破原型链"><a href="#不要在-f-函数的原型上直接定义-f-prototype-b-3-c-4-这样会直接打破原型链" class="headerlink" title="// 不要在 f 函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链"></a>// 不要在 f 函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链</h5><h5 id="o-Prototype-有属性-b-和-c"><a href="#o-Prototype-有属性-b-和-c" class="headerlink" title="// o.[[Prototype]] 有属性 b 和 c"></a>// o.[[Prototype]] 有属性 b 和 c</h5><h5 id="其实就是-o-proto-或者-o-constructor-prototype"><a href="#其实就是-o-proto-或者-o-constructor-prototype" class="headerlink" title="// (其实就是 o.proto 或者 o.constructor.prototype)"></a>// (其实就是 o.<strong>proto</strong> 或者 o.constructor.prototype)</h5><h5 id="o-Prototype-Prototype-是-Object-prototype"><a href="#o-Prototype-Prototype-是-Object-prototype" class="headerlink" title="// o.[[Prototype]].[[Prototype]] 是 Object.prototype."></a>// o.[[Prototype]].[[Prototype]] 是 Object.prototype.</h5><h5 id="最后-o-Prototype-Prototype-Prototype-是-null"><a href="#最后-o-Prototype-Prototype-Prototype-是-null" class="headerlink" title="// 最后 o.[[Prototype]].[[Prototype]].[[Prototype]]是 null"></a>// 最后 o.[[Prototype]].[[Prototype]].[[Prototype]]是 null</h5><h5 id="这就是原型链的末尾，即-null，"><a href="#这就是原型链的末尾，即-null，" class="headerlink" title="// 这就是原型链的末尾，即 null，"></a>// 这就是原型链的末尾，即 null，</h5><h5 id="根据定义，null-就是没有-Prototype-。"><a href="#根据定义，null-就是没有-Prototype-。" class="headerlink" title="// 根据定义，null 就是没有 [[Prototype]]。"></a>// 根据定义，null 就是没有 [[Prototype]]。</h5><h5 id="综上，整个原型链如下"><a href="#综上，整个原型链如下" class="headerlink" title="// 综上，整个原型链如下:"></a>// 综上，整个原型链如下:</h5><p>// {a:1, b:2} —&gt; {b:3, c:4} —&gt; Object.prototype—&gt; null</p>
<p>console.log(o.a); // 1</p>
<h5 id="a-是-o-的自身属性吗？是的，该属性的值为-1"><a href="#a-是-o-的自身属性吗？是的，该属性的值为-1" class="headerlink" title="// a 是 o 的自身属性吗？是的，该属性的值为 1"></a>// a 是 o 的自身属性吗？是的，该属性的值为 1</h5><p>console.log(o.b); // 2</p>
<h5 id="b-是-o-的自身属性吗？是的，该属性的值为-2"><a href="#b-是-o-的自身属性吗？是的，该属性的值为-2" class="headerlink" title="// b 是 o 的自身属性吗？是的，该属性的值为 2"></a>// b 是 o 的自身属性吗？是的，该属性的值为 2</h5><h5 id="原型上也有一个’b’属性，但是它不会被访问到。"><a href="#原型上也有一个’b’属性，但是它不会被访问到。" class="headerlink" title="// 原型上也有一个’b’属性，但是它不会被访问到。"></a>// 原型上也有一个’b’属性，但是它不会被访问到。</h5><h5 id="这种情况被称为”属性遮蔽-property-shadowing-”"><a href="#这种情况被称为”属性遮蔽-property-shadowing-”" class="headerlink" title="// 这种情况被称为”属性遮蔽 (property shadowing)”"></a>// 这种情况被称为”属性遮蔽 (property shadowing)”</h5><p>console.log(o.c); // 4</p>
<h5 id="c-是-o-的自身属性吗？不是，那看看它的原型上有没有"><a href="#c-是-o-的自身属性吗？不是，那看看它的原型上有没有" class="headerlink" title="// c 是 o 的自身属性吗？不是，那看看它的原型上有没有"></a>// c 是 o 的自身属性吗？不是，那看看它的原型上有没有</h5><h5 id="c-是-o-Prototype-的属性吗？是的，该属性的值为-4"><a href="#c-是-o-Prototype-的属性吗？是的，该属性的值为-4" class="headerlink" title="// c 是 o.[[Prototype]]的属性吗？是的，该属性的值为 4"></a>// c 是 o.[[Prototype]]的属性吗？是的，该属性的值为 4</h5><p>console.log(o.d); // undefined</p>
<h5 id="d-是-o-的自身属性吗？不是，那看看它的原型上有没有"><a href="#d-是-o-的自身属性吗？不是，那看看它的原型上有没有" class="headerlink" title="// d 是 o 的自身属性吗？不是，那看看它的原型上有没有"></a>// d 是 o 的自身属性吗？不是，那看看它的原型上有没有</h5><h5 id="d-是-o-Prototype-的属性吗？不是，那看看它的原型上有没有"><a href="#d-是-o-Prototype-的属性吗？不是，那看看它的原型上有没有" class="headerlink" title="// d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有"></a>// d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有</h5><h5 id="o-Prototype-Prototype-为-null，停止搜索"><a href="#o-Prototype-Prototype-为-null，停止搜索" class="headerlink" title="// o.[[Prototype]].[[Prototype]] 为 null，停止搜索"></a>// o.[[Prototype]].[[Prototype]] 为 null，停止搜索</h5><h5 id="找不到-d-属性，返回-undefined"><a href="#找不到-d-属性，返回-undefined" class="headerlink" title="// 找不到 d 属性，返回 undefined"></a>// 找不到 d 属性，返回 undefined</h5><h2 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h2><p>JavaScript 并没有其他基于类的语言所定义的“方法”。在 JavaScript 里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）。</p>
<p>当继承的函数被调用时，this 指向的是当前继承的对象，而不是继承的函数所在的原型对象。</p>
<p>var o = {<br>a: 2,<br>m: function(){<br>return this.a + 1;<br>}<br>};</p>
<p>console.log(o.m()); // 3</p>
<h5 id="当调用-o-m-时，’this’-指向了-o"><a href="#当调用-o-m-时，’this’-指向了-o" class="headerlink" title="// 当调用 o.m 时，’this’ 指向了 o."></a>// 当调用 o.m 时，’this’ 指向了 o.</h5><p>var p = Object.create(o);</p>
<h5 id="p-是一个继承自-o-的对象"><a href="#p-是一个继承自-o-的对象" class="headerlink" title="// p 是一个继承自 o 的对象"></a>// p 是一个继承自 o 的对象</h5><p>p.a = 4; // 创建 p 的自身属性 ‘a’<br>console.log(p.m()); // 5</p>
<h5 id="调用-p-m-时，’this’-指向了-p"><a href="#调用-p-m-时，’this’-指向了-p" class="headerlink" title="// 调用 p.m 时，’this’ 指向了 p"></a>// 调用 p.m 时，’this’ 指向了 p</h5><h5 id="又因为-p-继承了-o-的-m-函数"><a href="#又因为-p-继承了-o-的-m-函数" class="headerlink" title="// 又因为 p 继承了 o 的 m 函数"></a>// 又因为 p 继承了 o 的 m 函数</h5><h5 id="所以，此时的-‘this-a’-即-p-a，就是-p-的自身属性-‘a’"><a href="#所以，此时的-‘this-a’-即-p-a，就是-p-的自身属性-‘a’" class="headerlink" title="// 所以，此时的 ‘this.a’ 即 p.a，就是 p 的自身属性 ‘a’"></a>// 所以，此时的 ‘this.a’ 即 p.a，就是 p 的自身属性 ‘a’</h5><h2 id="使用构造器创建的对象"><a href="#使用构造器创建的对象" class="headerlink" title="使用构造器创建的对象"></a>使用构造器创建的对象</h2><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。</p>
<p>function Graph() {<br>this.vertices = [];<br>this.edges = [];<br>}</p>
<p>Graph.prototype = {<br>addVertex: function(v){<br>this.vertices.push(v);<br>}<br>};</p>
<p>var g = new Graph();</p>
<h5 id="g-是生成的对象，他的自身属性有-‘vertices’-和-‘edges’。"><a href="#g-是生成的对象，他的自身属性有-‘vertices’-和-‘edges’。" class="headerlink" title="// g 是生成的对象，他的自身属性有 ‘vertices’ 和 ‘edges’。"></a>// g 是生成的对象，他的自身属性有 ‘vertices’ 和 ‘edges’。</h5><h5 id="在-g-被实例化时，g-Prototype-指向了-Graph-prototype。"><a href="#在-g-被实例化时，g-Prototype-指向了-Graph-prototype。" class="headerlink" title="// 在 g 被实例化时，g.[[Prototype]] 指向了 Graph.prototype。"></a>// 在 g 被实例化时，g.[[Prototype]] 指向了 Graph.prototype。</h5><h2 id="使用-Object-create-创建的对象"><a href="#使用-Object-create-创建的对象" class="headerlink" title="使用 Object.create 创建的对象"></a>使用 Object.create 创建的对象</h2><p>ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：</p>
<p>var a = {a: 1};<br>// a —&gt; Object.prototype —&gt; null</p>
<p>var b = Object.create(a);<br>// b —&gt; a —&gt; Object.prototype —&gt; null<br>console.log(b.a); // 1 (继承而来)</p>
<p>var c = Object.create(b);<br>// c —&gt; b —&gt; a —&gt; Object.prototype —&gt; null</p>
<p>var d = Object.create(null);<br>// d —&gt; null<br>console.log(d.hasOwnProperty); // undefined, 因为 d 没有继承 Object.prototype</p>
<h2 id="使用-class-关键字创建的对象"><a href="#使用-class-关键字创建的对象" class="headerlink" title="使用 class 关键字创建的对象"></a>使用 class 关键字创建的对象</h2><p>ECMAScript6 引入了一套新的关键字用来实现 class。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不同的。JavaScript 仍然基于原型。这些新的关键字包括 class, constructor，static，extends 和 super。</p>
<p>“use strict”;</p>
<p>class Polygon {<br>constructor(height, width) {<br>this.height = height;<br>this.width = width;<br>}<br>}</p>
<p>class Square extends Polygon {<br>constructor(sideLength) {<br>super(sideLength, sideLength);<br>}<br>get area() {<br>return this.height * this.width;<br>}<br>set sideLength(newLength) {<br>this.height = newLength;<br>this.width = newLength;<br>}<br>}</p>
<p>var square = new Square(2);</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</p>
<p>遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从 Object.prototype 继承的 hasOwnProperty 方法。下面给出一个具体的例子来说明它：</p>
<p>console.log(g.hasOwnProperty(‘vertices’));<br>// true</p>
<p>console.log(g.hasOwnProperty(‘nope’));<br>// false</p>
<p>console.log(g.hasOwnProperty(‘addVertex’));<br>// false</p>
<p>console.log(g.<strong>proto</strong>.hasOwnProperty(‘addVertex’));<br>// true<br>hasOwnProperty 是 JavaScript 中唯一一个处理属性并且不会遍历原型链的方法。</p>
<h5 id="注意：检查属性是否为-undefined-是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了-undefined。"><a href="#注意：检查属性是否为-undefined-是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了-undefined。" class="headerlink" title="注意：检查属性是否为 undefined 是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了 undefined。"></a>注意：检查属性是否为 undefined 是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了 undefined。</h5><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><h5 id="在使用原型继承编写复杂代码之前，理解原型继承模型是至关重要的。此外，请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。此外，原生原型不应该被扩展，除非它是为了与新的-JavaScript-特性兼容。"><a href="#在使用原型继承编写复杂代码之前，理解原型继承模型是至关重要的。此外，请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。此外，原生原型不应该被扩展，除非它是为了与新的-JavaScript-特性兼容。" class="headerlink" title="在使用原型继承编写复杂代码之前，理解原型继承模型是至关重要的。此外，请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。此外，原生原型不应该被扩展，除非它是为了与新的 JavaScript 特性兼容。"></a>在使用原型继承编写复杂代码之前，理解原型继承模型是至关重要的。此外，请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。此外，原生原型不应该被扩展，除非它是为了与新的 JavaScript 特性兼容。</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/01/%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric.T">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/01/%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AB%A0/" itemprop="url">闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-01T19:41:13+08:00">
                2021-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官方说法：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
<p>我的理解：说到底就是方法里面定义局部变量，让外界方法执行时使用的是局部变量</p>
<h4 id="请看下面的代码："><a href="#请看下面的代码：" class="headerlink" title="请看下面的代码："></a>请看下面的代码：</h4><p>function init() {<br>var name = “Mozilla”; // name 是一个被 init 创建的局部变量<br>function displayName() { // displayName() 是内部函数，一个闭包<br>alert(name); // 使用了父函数中声明的变量<br>}<br>displayName();<br>}<br>init();</p>
<p>init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数，并且仅在 init() 函数体内可用。请注意，displayName() 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。</p>
<h4 id="我们看下面的一个例子"><a href="#我们看下面的一个例子" class="headerlink" title="我们看下面的一个例子"></a>我们看下面的一个例子</h4><p>function makeAdder(x) {<br>return function(y) {<br>return x + y;<br>};<br>}</p>
<p>var add5 = makeAdder(5);<br>var add10 = makeAdder(10);</p>
<p>console.log(add5(2)); // 7<br>console.log(add10(2)); // 12</p>
<p>在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数。返回的函数接受一个参数 y，并返回 x+y 的值。</p>
<p>从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p>
<p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。</p>
<h4 id="闭包常用于去抖截流函数"><a href="#闭包常用于去抖截流函数" class="headerlink" title="闭包常用于去抖截流函数"></a>闭包常用于去抖截流函数</h4><p>什么是节流和去抖？</p>
<h4 id="1、节流"><a href="#1、节流" class="headerlink" title="1、节流"></a>1、节流</h4><p>节流就是拧紧水龙头让水少流一点，但是不是不让水流了。想象一下在现实生活中有时候我们需要接一桶水，接水的同时不想一直站在那等着，可能要离开一会去干一点别的事请，让水差不多流满一桶水的时候再回来，这个时候，不能把水龙头开的太大，不然还没回来水就已经满了，浪费了好多水，这时候就需要节流，让自己回来的时候水差不多满了。</p>
<p>那在 JS 里有没有这种情况呢，典型的场景是图片懒加载监听页面的 scoll 事件，或者监听鼠标的 mousemove 事件，这些事件对应的处理方法相当于水，由于 scroll 和 mousemove 在鼠标移动的时候会被浏览器频繁的触发，会导致对应的事件也会被频繁的触发（水流的太快了），这样就会造成很大的浏览器资源开销，而且好多中间的处理是不必要的，这样就会造成浏览器卡顿的现象，这时候就需要节流。</p>
<p>如何节流呢？我们无法做到让浏览器不去触发对应的事件，但是可以做到让处理事件的方法执行频率减少，从而减少对应的处理开销。</p>
<h4 id="2、去抖"><a href="#2、去抖" class="headerlink" title="2、去抖"></a>2、去抖</h4><p>最早接触这个词应该是在高中物理里面学到的，有时候开关在在真正闭合之前可能会发生一些抖动现象，如果抖动的明显的话，对应的小灯泡可能会闪烁，把灯泡闪坏了不重要，万一把眼睛再给闪坏了可就麻烦了，这个时候就有去抖电路的出现。</p>
<p>而在我们的页面里，也有这种情况，假设我们的一个输入框，输入内容的同时可能会去后台查询对应的联想词，如果用户输入的同时，频繁的触发 input 事件，然后频繁的向后台发送请求，那么直到用户输入完成时，之前的请求都应该是多余的，假设网络慢一点，后台返回的数据比较慢，那么显示的联想词可能会出现频繁的变换，直到最后的一个请求返回。</p>
<p>如何去抖呢？这个时候就可以在一定时间内监听是否再次输入，如果没有再次输入则认为本次输入完成，发送请求，否则就是判定用户仍在输入，不发送请求。</p>
<h4 id="3、节流和去抖区别"><a href="#3、节流和去抖区别" class="headerlink" title="3、节流和去抖区别"></a>3、节流和去抖区别</h4><p>去抖和节流是不同的，因为节流虽然中间的处理函数被限制了，但是只是减少了频率，而去抖则把中间的处理函数全部过滤掉了，只执行规判定时间内的最后一个事件。</p>
<h3 id="JS-实现方式"><a href="#JS-实现方式" class="headerlink" title="JS 实现方式"></a>JS 实现方式</h3><h4 id="1、节流："><a href="#1、节流：" class="headerlink" title="1、节流："></a>1、节流：</h4><p>/** 实现思路：<br>** 参数需要一个执行的频率，和一个对应的处理函数,<br>** 内部需要一个 lastTime 变量记录上一次执行的时间<br>**/</p>
<p>function throttle(func, wait) {<br>let lastTime = null;// 为了避免每次调用 lastTime 都被清空，利用 js 的闭包返回一个 function;此外声明为全局变量也可以<br>return function() {<br>let now = new Date();<br>// 如果上次执行的时间和这次触发的时间大于一个执行周期，则执行<br>if (now - lastTime - wait &gt; 0) {<br>func();<br>lastTime = now;<br>}<br>}<br>}</p>
<h4 id="再看如何调用："><a href="#再看如何调用：" class="headerlink" title="再看如何调用："></a>再看如何调用：</h4><p>// 由于闭包的存在，调用会不一样<br>let throttleRun = throttle(() =&gt; {<br>console.log(123);<br>}, 400);<br>window.addEventListener(‘scroll’, throttleRun);</p>
<h3 id="2、去抖："><a href="#2、去抖：" class="headerlink" title="2、去抖："></a>2、去抖：</h3><p>去抖的方法，和节流思路一致，但是只有在抖动被判定结束后，方法才会得到执行。</p>
<p>function debounce(func, wait) {<br>let lastTime = null;<br>let timeout;<br>return function() {<br>let context = this;<br>let now = new Date();<br>// 判定不是一次抖动<br>if (now - lastTime - wait &gt; 0) {<br>setTimeout(() =&gt; {<br>func.apply(context, arguments);<br>}, wait);<br>} else {<br>if (timeout) {<br>clearTimeout(timeout);<br>timeout = null;<br>}<br>timeout = setTimeout(() =&gt; {<br>func.apply(context, arguments);<br>}, wait);<br>}<br>// 注意这里 lastTime 是上次的触发时间<br>lastTime = now;<br>}<br>}</p>
<h3 id="3、分享："><a href="#3、分享：" class="headerlink" title="3、分享："></a>3、分享：</h3><p>我们再给大家分享一下网友的实现方法的代码：</p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>这种实现方式的思路很好理解：设置一个一间隔时间，比如 50 毫秒，以此时间为基准设置定时器，当第一次触发事件到第二次触发事件间隔小于 50 毫秒时，清除这个定时器，并设置一个新的定时器，以此类推，直到有一次事件触发后 50 毫秒内没有重复触发。</p>
<p>代码如下：</p>
<p>function debounce(method) {<br>clearTimeout(method.timer);<br>method.timer = setTimeout(function() {<br>method();<br>}, 50);<br>}</p>
<p>这种设计方式有一个问题：本来应该多次触发的事件，可能最终只会发生一次。具体来说，一个循序渐进的滚动事件，如果用户滚动太快速，或者程序设置的函数节流间隔时间太长，那么最终滚动事件会呈现为一个很突然的跳跃事件，中间过程都被节流截掉了。这个例子举的有点夸张了，不过使用这种方式进行节流最终是会明显感受到程序比不节流的时候“更突兀”，这对于用户体验是很差的。有一种弥补这种缺陷的设计思路。</p>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>第二种实现方式的思路与第一种稍有差别：设置一个间隔时间，比如 50 毫秒，以此时间为基准稳定分隔事件触发情况，也就是说 100 毫秒内连续触发多次事件，也只会按照 50 毫秒一次稳定分隔执行。代码如下：</p>
<p>var oldTime = new Date().getTime();<br>var delay = 50;</p>
<p>function throttle1(method) {<br>var curTime = new Date().getTime();<br>if (curTime - oldTime &gt;= delay) {<br>oldTime = curTime;<br>method();<br>}<br>}</p>
<p>相比于第一种方法，第二种方法也许会比第一种方法执行更多次（有时候意味着更多次请求后台，即更多的流量），但是却很好的解决了第一种方法清除中间过程的缺陷。因此在具体场景应根据情况择优决定使用哪种方法。</p>
<p>对于方法二，我们再提供另一种同样功能的写法：(作者推荐)</p>
<p>var timer = undefined,<br>delay = 50;</p>
<p>function throttle2(method) {<br>if (timer) {<br>return;<br>}<br>method();<br>timer = setTimeout(function() {<br>timer = undefined;<br>}, delay);<br>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eric.T">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/28/hello-world/" itemprop="url">新年开篇-前端之路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-28T21:45:19+08:00">
                2021-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="新年新生-进阶的前端"><a href="#新年新生-进阶的前端" class="headerlink" title="新年新生 进阶的前端"></a>新年新生 进阶的前端</h2><p>今年是 2021 年，不知道写些什么好，一转眼从事前端已经 3 年多了，从当初的小白进阶成一名能独当一面的程序员了，其中的经历也值得我回味一下。</p>
<p>本人 18 年毕业于电子科技大学中山学院，在毕业之前便已经开始从事前端这个岗位，在毕业的时候已经有半年的工作经验，当时因为工资的关系选择了跳槽，去到了我的第二份工作中担任前端负责人，其实说是负责人整个公司也没有几人，全都是在用 jq 拧螺丝，在这个过程中我自学 Vue，一直到我掌握了 vue 基础之后便开始思考今后的路在何方。</p>
<p>在 19 年底我放弃了年终奖以及年底双薪跳巢于第三份工作，在这里能用得上我学的 Vue，能让我快速成长；跳槽之后的日子天天都是 007，虽然很累但是特别充实，感觉自己进步的特别快，学了许多 Vue 的生态以及测试。</p>
<p>到了 21 年初，公司开始重构项目用 react native 来做，这对我来说是一个挑战但更是一个充实自己的机会。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eric.T</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
