<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JS原型链 | Eric.T</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="官方说法：每个函数都有一个 prototype 属性每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 我的理解：说到底就是一个继承的方式，把你的某部分放入我这里，当你那部分改变时，我这里也会跟着改变 继承属性JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象">
<meta property="og:type" content="article">
<meta property="og:title" content="JS原型链">
<meta property="og:url" content="http://example.com/2021/03/02/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/index.html">
<meta property="og:site_name" content="Eric.T">
<meta property="og:description" content="官方说法：每个函数都有一个 prototype 属性每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 我的理解：说到底就是一个继承的方式，把你的某部分放入我这里，当你那部分改变时，我这里也会跟着改变 继承属性JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-02T13:00:33.000Z">
<meta property="article:modified_time" content="2021-03-02T13:14:10.303Z">
<meta property="article:author" content="Eric.T">
<meta property="article:tag" content="JS原型链">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Eric.T" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Eric.T</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JS原型链" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/02/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/" class="article-date">
  <time class="dt-published" datetime="2021-03-02T13:00:33.000Z" itemprop="datePublished">2021-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JS原型链
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>官方说法：每个函数都有一个 prototype 属性<br>每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>我的理解：说到底就是一个继承的方式，把你的某部分放入我这里，当你那部分改变时，我这里也会跟着改变</p>
<h2 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h2><p>JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<h5 id="让我们从一个函数里创建一个对象-o，它自身拥有属性-a-和-b-的："><a href="#让我们从一个函数里创建一个对象-o，它自身拥有属性-a-和-b-的：" class="headerlink" title="// 让我们从一个函数里创建一个对象 o，它自身拥有属性 a 和 b 的："></a>// 让我们从一个函数里创建一个对象 o，它自身拥有属性 a 和 b 的：</h5><p>let f = function () {<br>this.a = 1;<br>this.b = 2;<br>}</p>
<p>/_ 这么写也一样<br>function f() {<br>this.a = 1;<br>this.b = 2;<br>}<br>_/</p>
<p>let o = new f(); // {a: 1, b: 2}</p>
<p>// 在 f 函数的原型上定义属性</p>
<p>f.prototype.b = 3;</p>
<p>f.prototype.c = 4;</p>
<h5 id="不要在-f-函数的原型上直接定义-f-prototype-b-3-c-4-这样会直接打破原型链"><a href="#不要在-f-函数的原型上直接定义-f-prototype-b-3-c-4-这样会直接打破原型链" class="headerlink" title="// 不要在 f 函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链"></a>// 不要在 f 函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链</h5><h5 id="o-Prototype-有属性-b-和-c"><a href="#o-Prototype-有属性-b-和-c" class="headerlink" title="// o.[[Prototype]] 有属性 b 和 c"></a>// o.[[Prototype]] 有属性 b 和 c</h5><h5 id="其实就是-o-proto-或者-o-constructor-prototype"><a href="#其实就是-o-proto-或者-o-constructor-prototype" class="headerlink" title="// (其实就是 o.proto 或者 o.constructor.prototype)"></a>// (其实就是 o.<strong>proto</strong> 或者 o.constructor.prototype)</h5><h5 id="o-Prototype-Prototype-是-Object-prototype"><a href="#o-Prototype-Prototype-是-Object-prototype" class="headerlink" title="// o.[[Prototype]].[[Prototype]] 是 Object.prototype."></a>// o.[[Prototype]].[[Prototype]] 是 Object.prototype.</h5><h5 id="最后-o-Prototype-Prototype-Prototype-是-null"><a href="#最后-o-Prototype-Prototype-Prototype-是-null" class="headerlink" title="// 最后 o.[[Prototype]].[[Prototype]].[[Prototype]]是 null"></a>// 最后 o.[[Prototype]].[[Prototype]].[[Prototype]]是 null</h5><h5 id="这就是原型链的末尾，即-null，"><a href="#这就是原型链的末尾，即-null，" class="headerlink" title="// 这就是原型链的末尾，即 null，"></a>// 这就是原型链的末尾，即 null，</h5><h5 id="根据定义，null-就是没有-Prototype-。"><a href="#根据定义，null-就是没有-Prototype-。" class="headerlink" title="// 根据定义，null 就是没有 [[Prototype]]。"></a>// 根据定义，null 就是没有 [[Prototype]]。</h5><h5 id="综上，整个原型链如下"><a href="#综上，整个原型链如下" class="headerlink" title="// 综上，整个原型链如下:"></a>// 综上，整个原型链如下:</h5><p>// {a:1, b:2} —&gt; {b:3, c:4} —&gt; Object.prototype—&gt; null</p>
<p>console.log(o.a); // 1</p>
<h5 id="a-是-o-的自身属性吗？是的，该属性的值为-1"><a href="#a-是-o-的自身属性吗？是的，该属性的值为-1" class="headerlink" title="// a 是 o 的自身属性吗？是的，该属性的值为 1"></a>// a 是 o 的自身属性吗？是的，该属性的值为 1</h5><p>console.log(o.b); // 2</p>
<h5 id="b-是-o-的自身属性吗？是的，该属性的值为-2"><a href="#b-是-o-的自身属性吗？是的，该属性的值为-2" class="headerlink" title="// b 是 o 的自身属性吗？是的，该属性的值为 2"></a>// b 是 o 的自身属性吗？是的，该属性的值为 2</h5><h5 id="原型上也有一个’b’属性，但是它不会被访问到。"><a href="#原型上也有一个’b’属性，但是它不会被访问到。" class="headerlink" title="// 原型上也有一个’b’属性，但是它不会被访问到。"></a>// 原型上也有一个’b’属性，但是它不会被访问到。</h5><h5 id="这种情况被称为”属性遮蔽-property-shadowing-”"><a href="#这种情况被称为”属性遮蔽-property-shadowing-”" class="headerlink" title="// 这种情况被称为”属性遮蔽 (property shadowing)”"></a>// 这种情况被称为”属性遮蔽 (property shadowing)”</h5><p>console.log(o.c); // 4</p>
<h5 id="c-是-o-的自身属性吗？不是，那看看它的原型上有没有"><a href="#c-是-o-的自身属性吗？不是，那看看它的原型上有没有" class="headerlink" title="// c 是 o 的自身属性吗？不是，那看看它的原型上有没有"></a>// c 是 o 的自身属性吗？不是，那看看它的原型上有没有</h5><h5 id="c-是-o-Prototype-的属性吗？是的，该属性的值为-4"><a href="#c-是-o-Prototype-的属性吗？是的，该属性的值为-4" class="headerlink" title="// c 是 o.[[Prototype]]的属性吗？是的，该属性的值为 4"></a>// c 是 o.[[Prototype]]的属性吗？是的，该属性的值为 4</h5><p>console.log(o.d); // undefined</p>
<h5 id="d-是-o-的自身属性吗？不是，那看看它的原型上有没有"><a href="#d-是-o-的自身属性吗？不是，那看看它的原型上有没有" class="headerlink" title="// d 是 o 的自身属性吗？不是，那看看它的原型上有没有"></a>// d 是 o 的自身属性吗？不是，那看看它的原型上有没有</h5><h5 id="d-是-o-Prototype-的属性吗？不是，那看看它的原型上有没有"><a href="#d-是-o-Prototype-的属性吗？不是，那看看它的原型上有没有" class="headerlink" title="// d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有"></a>// d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有</h5><h5 id="o-Prototype-Prototype-为-null，停止搜索"><a href="#o-Prototype-Prototype-为-null，停止搜索" class="headerlink" title="// o.[[Prototype]].[[Prototype]] 为 null，停止搜索"></a>// o.[[Prototype]].[[Prototype]] 为 null，停止搜索</h5><h5 id="找不到-d-属性，返回-undefined"><a href="#找不到-d-属性，返回-undefined" class="headerlink" title="// 找不到 d 属性，返回 undefined"></a>// 找不到 d 属性，返回 undefined</h5><h2 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h2><p>JavaScript 并没有其他基于类的语言所定义的“方法”。在 JavaScript 里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）。</p>
<p>当继承的函数被调用时，this 指向的是当前继承的对象，而不是继承的函数所在的原型对象。</p>
<p>var o = {<br>a: 2,<br>m: function(){<br>return this.a + 1;<br>}<br>};</p>
<p>console.log(o.m()); // 3</p>
<h5 id="当调用-o-m-时，’this’-指向了-o"><a href="#当调用-o-m-时，’this’-指向了-o" class="headerlink" title="// 当调用 o.m 时，’this’ 指向了 o."></a>// 当调用 o.m 时，’this’ 指向了 o.</h5><p>var p = Object.create(o);</p>
<h5 id="p-是一个继承自-o-的对象"><a href="#p-是一个继承自-o-的对象" class="headerlink" title="// p 是一个继承自 o 的对象"></a>// p 是一个继承自 o 的对象</h5><p>p.a = 4; // 创建 p 的自身属性 ‘a’<br>console.log(p.m()); // 5</p>
<h5 id="调用-p-m-时，’this’-指向了-p"><a href="#调用-p-m-时，’this’-指向了-p" class="headerlink" title="// 调用 p.m 时，’this’ 指向了 p"></a>// 调用 p.m 时，’this’ 指向了 p</h5><h5 id="又因为-p-继承了-o-的-m-函数"><a href="#又因为-p-继承了-o-的-m-函数" class="headerlink" title="// 又因为 p 继承了 o 的 m 函数"></a>// 又因为 p 继承了 o 的 m 函数</h5><h5 id="所以，此时的-‘this-a’-即-p-a，就是-p-的自身属性-‘a’"><a href="#所以，此时的-‘this-a’-即-p-a，就是-p-的自身属性-‘a’" class="headerlink" title="// 所以，此时的 ‘this.a’ 即 p.a，就是 p 的自身属性 ‘a’"></a>// 所以，此时的 ‘this.a’ 即 p.a，就是 p 的自身属性 ‘a’</h5><h2 id="使用构造器创建的对象"><a href="#使用构造器创建的对象" class="headerlink" title="使用构造器创建的对象"></a>使用构造器创建的对象</h2><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。</p>
<p>function Graph() {<br>this.vertices = [];<br>this.edges = [];<br>}</p>
<p>Graph.prototype = {<br>addVertex: function(v){<br>this.vertices.push(v);<br>}<br>};</p>
<p>var g = new Graph();</p>
<h5 id="g-是生成的对象，他的自身属性有-‘vertices’-和-‘edges’。"><a href="#g-是生成的对象，他的自身属性有-‘vertices’-和-‘edges’。" class="headerlink" title="// g 是生成的对象，他的自身属性有 ‘vertices’ 和 ‘edges’。"></a>// g 是生成的对象，他的自身属性有 ‘vertices’ 和 ‘edges’。</h5><h5 id="在-g-被实例化时，g-Prototype-指向了-Graph-prototype。"><a href="#在-g-被实例化时，g-Prototype-指向了-Graph-prototype。" class="headerlink" title="// 在 g 被实例化时，g.[[Prototype]] 指向了 Graph.prototype。"></a>// 在 g 被实例化时，g.[[Prototype]] 指向了 Graph.prototype。</h5><h2 id="使用-Object-create-创建的对象"><a href="#使用-Object-create-创建的对象" class="headerlink" title="使用 Object.create 创建的对象"></a>使用 Object.create 创建的对象</h2><p>ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：</p>
<p>var a = {a: 1};<br>// a —&gt; Object.prototype —&gt; null</p>
<p>var b = Object.create(a);<br>// b —&gt; a —&gt; Object.prototype —&gt; null<br>console.log(b.a); // 1 (继承而来)</p>
<p>var c = Object.create(b);<br>// c —&gt; b —&gt; a —&gt; Object.prototype —&gt; null</p>
<p>var d = Object.create(null);<br>// d —&gt; null<br>console.log(d.hasOwnProperty); // undefined, 因为 d 没有继承 Object.prototype</p>
<h2 id="使用-class-关键字创建的对象"><a href="#使用-class-关键字创建的对象" class="headerlink" title="使用 class 关键字创建的对象"></a>使用 class 关键字创建的对象</h2><p>ECMAScript6 引入了一套新的关键字用来实现 class。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不同的。JavaScript 仍然基于原型。这些新的关键字包括 class, constructor，static，extends 和 super。</p>
<p>“use strict”;</p>
<p>class Polygon {<br>constructor(height, width) {<br>this.height = height;<br>this.width = width;<br>}<br>}</p>
<p>class Square extends Polygon {<br>constructor(sideLength) {<br>super(sideLength, sideLength);<br>}<br>get area() {<br>return this.height * this.width;<br>}<br>set sideLength(newLength) {<br>this.height = newLength;<br>this.width = newLength;<br>}<br>}</p>
<p>var square = new Square(2);</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</p>
<p>遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从 Object.prototype 继承的 hasOwnProperty 方法。下面给出一个具体的例子来说明它：</p>
<p>console.log(g.hasOwnProperty(‘vertices’));<br>// true</p>
<p>console.log(g.hasOwnProperty(‘nope’));<br>// false</p>
<p>console.log(g.hasOwnProperty(‘addVertex’));<br>// false</p>
<p>console.log(g.<strong>proto</strong>.hasOwnProperty(‘addVertex’));<br>// true<br>hasOwnProperty 是 JavaScript 中唯一一个处理属性并且不会遍历原型链的方法。</p>
<h5 id="注意：检查属性是否为-undefined-是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了-undefined。"><a href="#注意：检查属性是否为-undefined-是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了-undefined。" class="headerlink" title="注意：检查属性是否为 undefined 是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了 undefined。"></a>注意：检查属性是否为 undefined 是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了 undefined。</h5><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><h5 id="在使用原型继承编写复杂代码之前，理解原型继承模型是至关重要的。此外，请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。此外，原生原型不应该被扩展，除非它是为了与新的-JavaScript-特性兼容。"><a href="#在使用原型继承编写复杂代码之前，理解原型继承模型是至关重要的。此外，请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。此外，原生原型不应该被扩展，除非它是为了与新的-JavaScript-特性兼容。" class="headerlink" title="在使用原型继承编写复杂代码之前，理解原型继承模型是至关重要的。此外，请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。此外，原生原型不应该被扩展，除非它是为了与新的 JavaScript 特性兼容。"></a>在使用原型继承编写复杂代码之前，理解原型继承模型是至关重要的。此外，请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。此外，原生原型不应该被扩展，除非它是为了与新的 JavaScript 特性兼容。</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/02/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/" data-id="ckls1as2z0000mcsxabesg5m8" data-title="JS原型链" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">JS原型链</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/03/02/%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AB%A0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">闭包</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">JS原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/" style="font-size: 10px;">JS原型链</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/02/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/">JS原型链</a>
          </li>
        
          <li>
            <a href="/2021/03/02/%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AB%A0/">闭包</a>
          </li>
        
          <li>
            <a href="/2021/03/01/hello-world/">新年开篇-前端之路</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Eric.T<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>